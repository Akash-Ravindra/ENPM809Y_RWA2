/**
 * @file mouse.h
 * @author Akash Ravindra (aravind2@umd.edu)
 * @brief
 * @version 0.1
 * @date 2021-11-08
 *
 * @copyright Copyright (c) 2021
 *
 */

/*! \mainpage Maze search algorithm
 *
 * This project consists of searching a path in a maze
 * and then task a mouse (robot) to follow the path.
 * - \subpage searchingPathPage "Searching a path"
 *
 * - \subpage followingPathPage "Following a path"
 */

/*! \page searchingPathPage Searching a path
 *
 * The search algorithm used for searching a path in a maze relies on
 * the depth-first search (DFS) approach. This algorithm is implemented in
 * rwa2::Mouse::search_maze(Node *)
 *
 */


/*! \page followingPathPage Following a path
 *
 * To follow a path generated by DFS, methods from the class API (api/api.h)
 * must be used to interact with the micromouse simulator.
 * - Methods of the API class are documented <a
 * href="https://github.com/mackorone/mms#summary">here</a>.
 */

#ifndef MICROMOUSE_H
#define MICROMOUSE_H

#include "../node/node.h"
#include <array>
#include <iostream>
#include <stack>
#include <vector>

namespace rwa2 {
/**
 * @brief This class is used to compute a path and execute the path.
 *
 */
class Mouse {
public:
  /**
   * @brief Construct a new MicroMouse object
   *
   * The robot is always at (0,0) and facing NORTH when the simulator starts
   */
  Mouse()
      : m_direction{direction::NORTH},
        // lookup table: The Global orientation w.r.t Mouse orientation
        // Global---|Front|Right|Back|Left|
        // N--------|N    |E    |S   |W   |
        // E--------|E    |S    |W   |N   |
        // S--------|S    |W    |N   |E   |
        // W--------|W    |N    |E   |S   |
        m_look_up_table{{{{NORTH, EAST, SOUTH, WEST}},
                         {{EAST, SOUTH, WEST, NORTH}},
                         {{SOUTH, WEST, NORTH, EAST}},
                         {{WEST, NORTH, EAST, SOUTH}}}} {
    // initialize the maze by placing around the perimeter of the maze
    for (int x = 0; x < m_maze_width; x += 1) {
      for (int y = 0; y < m_maze_height; y += 1) {
        m_maze.at(x).at(y).set_cords({x, y});
        m_maze.at(x).at(y).set_wall(direction::NORTH, (y == m_maze_height - 1));
        m_maze.at(x).at(y).set_wall(direction::EAST, (x == m_maze_width - 1));
        m_maze.at(x).at(y).set_wall(direction::SOUTH, (y == 0));
        m_maze.at(x).at(y).set_wall(direction::WEST, (x == 0));
      }
    }
  }
  /**
   * @brief  This method visually sets the walls in the simulator
   * @details Uses the current node to set the walls and the text at the node.
   * If nothing is provided it applies these changes to the whole maze
   *
   */
  void display_walls(Node *);
  // IMPLEMENT THE METHODS BELOW
  // Note: Come up with your own parameters and implementations
  /**
   * @brief Implement DFS to compute a path between 2 nodes in a maze
   * @details description
   * @return true A path is found
   * @return false A path is not found
   */
  bool search_maze(Node *);

  /**
   * @brief Get the nodeList object
   * @details Gives the list of nodes which the mouse has visited.
   * @return const std::vector<Node>&
   */
  const std::vector<std::array<int, 2>> &get_nodeList() {
    return m_list_of_nodes;
  }
  /**
   * @brief Get the nodeStack object
   *@details Gives the stack of nodes the mouse has traversed.
   * @return const std::stack<Node>&
   */
  const std::stack<Node *> &get_nodeStack() { return m_stack_of_nodes; }
  /**
   * @brief Used to run the mouse from home to goal based on the provided stack
   *
   */
  void maze_runner(std::stack<Node *>);

  /**
   * @brief When called resents the mouse to the home poisiton and also the
   * m_direction values to NORTH
   *
   */
  void reset_mouse();
  /**
   * @brief  Displays the path the mouse has traversed
   * @details As the mouse traverses, It sets color to the nodes travelled.
   *
   */
  void display_path();
  /**
   * @brief Get the home node object
   * @details The home node/start point is declared to be at the origin
   * @return Node*
   */
  Node *get_home_node() { return &m_maze.at(0).at(0); };
  /**
   * @brief Get the goal position object
   * @details The goal position coordinates are returned when this function is
   * called.
   * @return const std::array<int,2>
   */
  const std::array<int, 2> get_goal_position() { return m_goal_position; }
  /**
   * @brief Set the goal position object
   * @details The goal position coordinates can be changed and reset if the user
   * requires. The default goal is set to be (7,7)
   * @param gp
   */
  void set_goal_position(std::array<int, 2> gp) { m_goal_position = gp; }
  void log(const std::string &text) { std::cerr << text << std::endl; }

private:
  /**
   * @brief Displays text on the right pane of the maze display
   * @details The function is used to display text on the maze application.
   * @param text
   */
  // void log(const std::string &text) { std::cerr << text << std::endl; }
  /**
   * @brief Make the mouse move forward
   */
  void move_forward();
  /**
   * @brief Make the mouse rotate 90 deg CCW
   *
   */
  void turn_left();
  /**
   * @brief Make the mouse rotate 90 deg CW
   *
   */
  void turn_right();
  /**
   * @brief Makes the mouse rotate 180 deg CW
   * @details This is used when the mouse reaches a completely blocked node and
   * needs to backtrack by taking a 180 degree flip.
   *
   */
  void flip_around();
  /**
   * @brief Looks around to find walls at the current nodes
   * @details It uses a Lookup table to align the the global position w.r.t to
   * the mouse positioning.
   */
  void look_around(Node *);
  /**
   * @brief Turns the mouse until it alignes the mouse direction to the required
   * direction (argument)
   * @details The mouse direction i.e. m_direction is turned by 90 degree until
   * it reaches the the direction passed in the argument.
   */
  void turn_until_direction(direction);
  /**
   * @brief Moves the mouse based on the two supplied nodes
   * @details Need to provide the current node and the node that it is supposed
   * to move to.
   */
  void move_to(Node *, Node *);
  /**
   * @brief Checks if the neighbour node has been visited.
   * @details Checks if the North,East,South and West Nodes have been visited
   * and gets the current node from the m_visited list.
   *
   * @return true
   * @return false
   */
  bool is_neighbor_visited(Node *, direction);

  static const int m_maze_width{16};  // width of the maze
  static const int m_maze_height{16}; // height of the maze
  int m_direction;                    // direction of the robot in the maze
  std::array<std::array<Node, m_maze_width>, m_maze_height>
      m_maze;                                      // 2D array maze object
  std::vector<std::array<int, 2>> m_list_of_nodes; // 2D array of list of nodes
  std::stack<Node *> m_stack_of_nodes; // Stack of nodes of type Node
  /**
   * @brief // Lookup table for the look_Around function. Gives the relative
   * orientation of global w.r.t to the mouse's orientation.
   *
   */
  std::array<std::array<direction, 4>, 4> m_look_up_table;
  /**
   * @brief // Position of the goal, default value is (7,7). Can be changed by
   * the user using the getter and setter.
   *
   */
  std::array<int, 2> m_goal_position{7, 7};
};
} // namespace rwa2
#endif