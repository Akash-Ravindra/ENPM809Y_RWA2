/**
 * @file mouse.h
 * @author Akash Ravindra (aravind2@umd.edu)
 * @brief
 * @version 0.1
 * @date 2021-11-08
 *
 * @copyright Copyright (c) 2021
 *
 */

/*! \mainpage Maze search algorithm
 *
 * This project consists of searching a path in a maze
 * and then task a mouse (robot) to follow the path.
 * - \subpage searchingPathPage "Searching a path"
 *
 * - \subpage followingPathPage "Following a path"
 *
 */

/*! \page searchingPathPage Searching a path
 *
 * The search algorithm used for searching a path in a maze relies on
 * the depth-first search (DFS) approach. This algorithm is implemented in
 * rwa2::Mouse::search_maze()
 *
 */

/*! \page followingPathPage Following a path
 *
 * To follow a path generated by DFS, methods from the class API (api/api.h)
 * must be used to interact with the micromouse simulator.
 * - Methods of the API class are documented <a
 * href="https://github.com/mackorone/mms#summary">here</a>.
 */

#ifndef MICROMOUSE_H
#define MICROMOUSE_H

#include "../node/node.h"
#include <array>
#include <iostream>
#include <stack>
#include <vector>

namespace rwa2 {
/**
 * @brief This class is used to compute a path and execute the path.
 *
 */
class Mouse {
public:
  /**
   * @brief Construct a new MicroMouse object
   *
   * The robot is always at (0,0) and facing NORTH when the simulator starts
   */
  Mouse()
      : m_x{0}, m_y{0}, m_direction{direction::NORTH},
        //lookup table: The Global orientation w.r.t Mouse orientation
        //Global---|Front|Right|Back|Left|
        //N--------|N    |E    |S   |W   |
        //E--------|E    |S    |W   |N   |
        //S--------|S    |W    |N   |E   |
        //W--------|W    |N    |E   |S   |
        m_look_up_table{{{{NORTH, EAST, SOUTH, WEST}},
                         {{EAST, SOUTH, WEST, NORTH}},
                         {{SOUTH, WEST, NORTH, EAST}},
                         {{WEST, NORTH, EAST, SOUTH}}}} {
    // initialize the maze by placing around the perimeter of the maze
    for (int x = 0; x < m_maze_width; x += 1) {
      for (int y = 0; y < m_maze_height; y += 1) {
        m_maze.at(x).at(y).set_cords({x, y});
        m_maze.at(x).at(y).set_wall(direction::NORTH, (y == m_maze_height - 1));
        m_maze.at(x).at(y).set_wall(direction::EAST, (x == m_maze_width - 1));
        m_maze.at(x).at(y).set_wall(direction::SOUTH, (y == 0));
        m_maze.at(x).at(y).set_wall(direction::WEST, (x == 0));
      }
    }
  }
  // this method visually sets the walls in the simulator
  void display_walls(Node *);
  // IMPLEMENT THE METHODS BELOW
  // Note: Come up with your own parameters and implementations
  /**
   * @brief Implement DFS to compute a path between 2 nodes in a maze
   * @details description
   * @return true A path is found
   * @return false A path is not found
   */
  bool search_maze(Node *);

  /**
   * @brief Get the nodeList object
   * @details Gives the list of nodes which the mouse has visited.
   * @return const std::vector<Node>&
   */
  const std::vector<std::array<int, 2>> &get_nodeList() {
    return m_list_of_nodes;
  }
  /**
   * @brief Get the nodeStack object
   *@details Gives the stack of nodes the mouse has traversed.
   * @return const std::stack<Node>&
   */
  const std::stack<Node *> &get_nodeStack() { return m_stack_of_nodes; }
  /**
   * @brief 
   * 
   */
  void run_maze(std::stack<Node*>);

  /**
   * @brief 
   * 
   */
  void reset_mouse();
  /**
   * @brief  Displays the path the mouse has traversed
   * @details As the mouse traverses, It sets color to the nodes travelled.
   * 
   */
  void display_path();
  /**
   * @brief Get the home node object
   * @details The home node/start point is declared to be at the origin
   * @return Node* 
   */
  Node *get_home_node() { return &m_maze.at(0).at(0); };
  /**
   * @brief Get the goal position object
   * @details The goal position coordinates are returned when this function is called.
   * @return const std::array<int,2> 
   */
  const std::array<int,2> get_goal_position(){return m_goal_position;}
  /**
   * @brief Set the goal position object
   * @details The goal position coordinates can be changed and reset if the user requires. The default goal is set to be (7,7)
   * @param gp 
   */
  void set_goal_position(std::array<int,2> gp){m_goal_position = gp;}

private:
  /**
   * @brief Displays text on the right pane of the maze display
   * @details The function is used to display text on the maze application. 
   * @param text 
   */
  void log(const std::string &text) { std::cerr << text << std::endl; }
  /**
   * @brief Make the mouse move forward
   */
  void move_forward();
  /**
   * @brief Make the mouse rotate 90 deg CCW
   *
   */
  void turn_left();
  /**
   * @brief Make the mouse rotate 90 deg CW
   *
   */
  void turn_right();
  /**
   * @brief Makes the mouse rotate 180 deg CW
   * @details This is used when the mouse reaches a completely blocked node and needs to backtrack by taking a 180 degree flip.
   *
   */
  void flip_around();
  /**
   * @brief Looks around to find walls at the current nodes
   * @details It uses a Lookup table to align the the global position w.r.t to the mouse positioning.
   */
  void look_around(Node *);
  /**
   * @brief Turns the mouse until it alignes the mouse direction to the required direction (argument)
   * @details The mouse direction i.e. m_direction is turned by 90 degree until it reaches the the direction passed in the argument.
   */
  void turn_until_direction(direction);
  /**
   * @brief Moves the mouse when it reaches a dead end
   * @details Moves the mouse to the last element popped from the stack 
   */
  void move_backward(Node *, Node *);
  std::array<int, 2> my_neighbor_cords(std::array<int, 2>, direction);//array of neighbour coordinates
  /**
   * @brief Checks if the neighbour node has been visited.
   * @details Checks if the North,East,South and West Nodes have been visited and gets the current node from the m_visited list.
   * 
   * @return true 
   * @return false 
   */
  bool is_neighbor_visited(Node *, direction);

  static const int m_maze_width{16};  // width of the maze
  static const int m_maze_height{16}; // height of the maze
  int m_x;                            // x position of the robot in the maze
  int m_y;                            // y position of the robot in the maze
  int m_direction;                    // direction of the robot in the maze
  std::array<std::array<Node, m_maze_width>, m_maze_height> 
      m_maze; // 2D array maze object
  std::vector<std::array<int, 2>> m_list_of_nodes; //2D array of list of nodes
  std::stack<Node *> m_stack_of_nodes;//Stack of nodes of type Node
  std::array<std::array<direction, 4>, 4> m_look_up_table;// Lookup table for the look_Around function. Gives the relative orientation of global w.r.t to the mouse's orientation.
  std::array<int,2> m_goal_position{7,7};//Position of the goal, default value is (7,7). Can be changed by the user using the getter and setter.
};
} // namespace rwa2
#endif